{{- $platform := "bmrg" -}}
{{- $product := "bosun" -}}
{{- $tier := "opa" -}}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "bmrg.name" (dict "context" $ "tier" $tier ) }}
  labels:
    {{- include "bmrg.labels.chart" (dict "context" $ "tier" $tier ) | nindent 4 }}
data:
  citadel.static_code_analysis.rego: |
    package citadel.static_code_analysis

    default valid = false

    valid = true {
      count(rules) >= 0
      count(violations) == 0
    }

    rules[{
      "metric": metric,
      "value": value,
      "operator": operator, 
      "measure": measure
    }] {
      metric := input.policy.rules[i].metric
      rule := input.policy.rules[i]
      measure := rule.value
      operator := rule.operator
      value := input.data.measures[metric]
    } {
      metric := input.policy.rules[i].metric
      rule := input.policy.rules[i]
      measure := rule.value
      operator := rule.operator
      metricSplit := split(metric, "-")
      metricCategory := metricSplit[0]
      metricKey := metricSplit[1]
      metricCategory == "issues"
      value := input.data.issues[metricKey]
    }

    violations[{
      "metric": metric,
      "message": message,
      "valid": false
    }] {
      metric := rules[i].metric
      not valid_value(rules[i].value, rules[i].measure, rules[i].operator)
      message := sprintf("%v %s %v was not satisfied", [rules[i].value, rules[i].operator, rules[i].measure])
    }

    valid_value(value, measure, operator) {
      operator == "equal"
      to_number(value) = to_number(measure)
    } else {
      operator == "not equal"
      to_number(value) != to_number(measure)
    } else {
      operator == "less than"
      to_number(value) < to_number(measure)
    } else {
      operator == "less than or equal"
      to_number(value) <= to_number(measure)
    }  else {
      operator == "greater than"
      to_number(value) > to_number(measure)
    } else {
      operator == "greater than or equal"
      to_number(value) >= to_number(measure)
    }
  citadel.unit_tests.rego: |
    package citadel.unit_tests

    default valid = false

    valid = true {
      count(rules) >= 0
      count(violations) == 0
    }

    rules[{
      "metric": metric,
      "value": value,
      "operator": operator, 
      "measure": measure
    }] {
      metric := input.policy.rules[i].metric
      rule := input.policy.rules[i]
      measure := rule.value
      operator := rule.operator
      value := input.data.measures[metric]
    }

    violations[{
      "metric": metric,
      "message": message,
      "valid": false
    }] {
      metric := rules[i].metric
      not valid_value(rules[i].value, rules[i].measure, rules[i].operator)
      message := sprintf("%v %s %v was not satisfied", [rules[i].value, rules[i].operator, rules[i].measure])
    }

    valid_value(value, measure, operator) {
      operator == "equal"
      to_number(value) = to_number(measure)
    } else {
      operator == "not equal"
      to_number(value) != to_number(measure)
    } else {
      operator == "less than"
      to_number(value) < to_number(measure)
    } else {
      operator == "less than or equal"
      to_number(value) <= to_number(measure)
    }  else {
      operator == "greater than"
      to_number(value) > to_number(measure)
    } else {
      operator == "greater than or equal"
      to_number(value) >= to_number(measure)
    }
  citadel.package_safelist.rego: |
    package citadel.package_safelist

    default valid = false

    valid = true {
      count(rules) >= 0
      count(violations) == 0
    }

    rules[{
      "type": "maven",
      "artifact": artifact,
      "version": version,
      "metric": metric
    }] {
      artifact := input.policy.rules[i].artifact
      version := input.policy.rules[i].version
      metric := concat("", ["^.*:", artifact, ":", version, "$"])
    }

    violations[{
      "metric": metric,
      "message": message,
      "valid": false
    }] {
      metric := rules[i].metric
      rules_not_matched[_].metric == metric
      message := sprintf("Package rule not met. Artifact: %s, and Version: %s", [rules[i].artifact, rules[i].version])
    }

    library[output] {
      output := input.data.components[_].components[_].component_id
    }

    rules_matched[output] {
      output := rules[i]
      re_match(rules[i].metric, input.data.components[_].components[_].component_id)
    }

    rules_not_matched = rules - rules_matched
  citadel.cve_safelist.rego: |
    package citadel.cve_safelist

    default valid = false

    valid = true {
      count(rules) >= 0
      count(violations) == 0
    }

    rules[{
      "metric": metric
    }] {
      metric := concat("", ["^", input.policy.rules[_].cve, "$"])
    }

    violations[{
      "metric": metric,
      "message": message,
      "valid": false
    }] {
      metric := rules[i].metric
      rules_matched[_].metric == metric
      message := sprintf("CVE rule matched. Rule: %s", [metric])
    }

    cves[output] { 
      output := input.data.issues[_].cves[_].cve
    }

    rules_matched[output] {
      output := rules[i]
      re_match(rules[i].metric, cves[_])
    }
  citadel.security_issue_analysis.rego: |
    package citadel.security_issue_analysis

    default valid = false
    default allIssues = 0
    default criticalIssues = 0
    default highIssues = 0
    default mediumIssues = 0
    default lowIssues = 0

    valid {
      allValid := [output | output := summary[_].valid]
      all(allValid)
    }

    allIssues = count(input.data.issues)

    criticalIssuesList[output] {
      issue := input.data.issues[_]
      issue.severity == "Critical"
      output := issue
    }
    criticalIssues = output {
      issue := input.data.issues[_]
      issue.severity == "Critical"
      output = count(issue)
    } else = output {
      output = 0
    }

    highIssuesList[output] {
      issue := input.data.issues[_]
      issue.severity == "High"
      output := issue
    }
    highIssues = count(highIssuesList)

    mediumIssuesList[output] {
      issue := input.data.issues[_]
      issue.severity == "Medium"
      output := issue
    }
    mediumIssues = count(mediumIssuesList)

    lowIssuesList[output] {
      issue := input.data.issues[_]
      issue.severity == "Low"
      output := issue
    }
    lowIssues = count(lowIssuesList)


    summary[output] {
      output := issues_matched("All")
    } {
      output := issues_matched("Critical")
    } {
      output := issues_matched("High")
    } {
      output := issues_matched("Medium")
    } {
      output := issues_matched("Low")
    }

    issues_detail = { "All": allIssues, "Critical": criticalIssues, "High": highIssues, "Medium": mediumIssues, "Low": lowIssues }

    issues_matched(severity) = output {
      rule := input.policy.rules[i]
      rule.severity == severity
      issueCount := issues_detail[severity]
      valid_value(rule.count, issueCount, rule.operator)
      output := issues_object(severity, issueCount, rule.count, rule.operator, true)
    } else = output {
      rule := input.policy.rules[i]
      rule.severity == severity
      issueCount := issues_detail[severity]
      output := issues_object(severity, issueCount, rule.count, rule.operator, false)
    } 

    issues_object(severity, issues, rule, operator, valid) = { "severity": severity, "issues" : issues, "rule": rule, "operator": operator, "valid": valid }

    valid_value(rule, value, operator) {
      operator == "equal"
      to_number(value) = to_number(rule)
    } else {
      operator == "not equal"
      to_number(value) != to_number(rule)
    } else {
      operator == "less than"
      to_number(value) < to_number(rule)
    } else {
      operator == "less than or equal"
      to_number(value) <= to_number(rule)
    }  else {
      operator == "greater than"
      to_number(value) > to_number(rule)
    } else {
      operator == "greater than or equal"
      to_number(value) >= to_number(rule)
    }

    violations[{
      "metric": metric,
      "message": message,
      "valid": false
    }] {
      not summary[i].valid
      metric := sprintf("%v %s Issues", [summary[i].issues, summary[i].severity])
      message := sprintf("%v %s %v %s Issues was not satisfied", [summary[i].issues, summary[i].operator, summary[i].rule, summary[i].severity])
    }